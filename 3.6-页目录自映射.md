# 第三章 内存管理

# 3.6 页目录自映射

> ### Week 5~6 :sob:

## 3.6.1 页式内存管理的回顾

页式内存管理思想：破除内存分配“连续性假设”

页表的作用是将 **虚拟地址空间** 映射到 **物理地址空间**

**页表的大小** 与 **逻辑地址空间** 大小成正比

多级页表：继续破除页表存储的连续性假设

动态调入页表 : 只将当前需用的部分页表项调入内存其余的需用时再调入。



## 3.6.2 页表的管理需求

OS来管理页表，填写页表的目的：反映**内存布局**。修改页表：写页表所在内存

### 二级页表

- 页目录：页表页的地址映射
- 1024个页表页逻辑上连续，物理上可以分散，对应的逻辑-物理映射关系记录在页目录中
- 页目录占4KB空间，有1024个页目录项，每一个页目录项指向一个页表页（即4MB内存，因为有1024个4B大小的页表项）。1024个页目录项正好对应4GB内存。



## 3.6.3 页目录自映射的任务

自映射：页目录中有一条PDE（Page Directory Entry）指向自身**物理地址**，也就是页目录**基地址**



## 3.6.4 页目录自映射的原理

就是让一级页表、二级页表也可以像其他普通页一样**可以用虚拟地址访问**。

页目录是页表页的地址映射，1024个页表页逻辑连续、物理分散，逻辑-物理关系记录在页目录中。

- 存储页表的4MB地址空间是整个4GB虚拟地址空间的一部分，即这4MB在4GB中
- 记录这4MB**连续地址空间到物理地址空间的映射关系**的是一个4KB的页目录
- 记录这4MB连续地址空间到物理地址空间的映射关系的是一个4KB的页表页(4MB页表中的一员)

亦即，页目录和页表页相同，页目录不用额外分配单独存储空间，即有一个4KB的空间可以同时作为页目录和一个页表项，它表示了整个页表的4MB地址空间与物理空间的映射关系。

### 二级页表

假设**第k张二级页表（注意不是页表项）虚拟地址为0x(t)(k)(0)**，在MMU中首先找到CR3中的一级页表物理地址，然后找到一级页表中的第t项。

MMU读出第t项中的物理地址（由页目录自映射，**这个第t项就是指向自身物理地址的PDE**），就是**一级页表物理基地址**，这就是二级页表的页表了。

MMU再查询一级页表的第k条，拿到了第k张二级页表的物理地址，完成。

### 一级页表

一级页表的虚拟地址就是0x(t)(t)(0)，在MMU中首先找到CR3中的一级页表物理地址，然后找到一级页表中的第t项。

MMU读出第t项中的物理地址（由页目录自映射，**这个第t项就是指向自身物理地址的PDE**），就是**一级页表物理基地址**，这就是二级页表的页表了。

MMU再查询一级页表的第t条，拿到了第t张二级页表（**还是一级页表！**）的物理地址，完成。

> 以上总结自知乎和CSDN，以下来自PPT

总结：页目录自映射关键点

- 整个 4GB **虚拟地址** 空间中 **任一个 4MB 都行** （4MB 对齐），OS 设计者可规定其所在位置

  > 指的是页目录首地址可以是任何位置，由系统设定

- 一方面根据页目录的定义：

  - 选中的 4MB 在整个虚存的 索引 = 对应页目录 自映射项 的索引
  - 记录这 4MB （连续）地址空间到物理地址空间映射关系的，是一个 4KB 的页目录

- 另一方面根据页表页的定义：

  - **页目录 = 自映射的页表**，表示整个 4MB 到对应物理页表的映射
  - 记录这 4MB （连续）地址空间到物理地址空间映射关系的，是一个 4KB 的页表页 （当然，它属于整个 4MB 页表的一部分）
  - 所以， **页目录** 和上述 **页表页** 内容相同，页目录无需额外分配单独的存储空间

## 3.6.5 页目录自映射的实现

二级页表中：

`PT_base`：页表基址，应当4MB对齐（一段大空间的首地址）

`PD_base`：页目录基址
$$
PD_{base} = PT_{base} + PT_{base} >> 10
$$

> 解释：**页目录第一个页目录项一定也是记录着第一个页表页的页表项**。$PT_{base} >> 12$​表示第一个页表页的物理页号，一个页表项占4B空间，所以记录第一个页表页的页表项 相对页表的偏移为
>
> $(PT_{base}>>12)<<2 = (PT_{base}>>10)$​，
>
> 可得记录第一个页表页的页表项的地址为$PT_{base} + PT_{base}>>10$​，这就是页目录第一个页目录项的地址，即页目录基址。

`PDE_self_mapping`：自映射目录表项
$$
PDE_{self-mapping}=PT_{base}+PT_{base}>>10+ PT_{base}>> 20
$$

> 解释：已经得到页目录基址，只需计算出该页目录项相对于页目录基址的偏移。
>
> 页目录项对应的是页表页，那么只需要计算当前页表页的页表页号即可。已经计算出来第一个页表页的页表项地址（即页目录基址）相对页表基址的偏移为$(PT_{base}>>10)$，一个页表页4KB，所以页目录的页表页号为 $((PT_{base}>>10)>>12)$，一个页表项4B，故偏移为$((PT_{base}>>10)>>12)<<2$。

> [!IMPORTANT]
>
> **只要给定 4M 对齐的页表基址**（虚拟地址），就可以得到**所有**页表项对应的地址，也就包括页目录表基址和自映射页目录项在页目录表中的位置。因此页目录表基址和自映射页目录项在虚空间中是计算出来的。
>
> 页表主要供 OS 使用的，因此 页表和页目录表**通常放置在 OS 空间中** （如 Win 的高 2G 空间）；
>
> “页目录自映射”的含义是 **页目录包含在页表当中**，是我们采用的映射（或组织）方法的一个特征， **是虚拟地址空间内的映射，**==与虚拟地址到物理地址的映射无关！==
>
> 支持“页目录自映射” **可节省 4K （虚拟地址）空间**



## 3.6.6 扩展到多级页目录

